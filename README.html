<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>File System Emulator</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="file-system-emulator">File System Emulator</h1>
<p>The goal of this project was to create a system where the user can create, read, update and delete files and directories in a way that maximized usable space on the drive and enabled fast read and writes without using too much main memory.</p>
<h2 id="general-structure">General Structure</h2>
<p>This file system works by dividing the space it uses into blocks of a given size (256 bytes is used here by default) in which either a file or a segment of a file is saved. Each block also has a header (2 bytes used by default) which hold meta-data about that specific block and the file of which it holds the data.</p>
<p>The first byte is used as a set of flags. Only one flag is used as of now to indicate whether or not the block is the last block comprising a file or not. The remaining bits in this byte can be used to store further meta-data like file types and user permissions in the future making this system extensible. The next byte can contain one of two pieces of information.</p>
<p>If the block is not the last block, the second byte directs us to the next block we need to complete our file. If the block is indeed the last block, the next byte tells us how many bytes inside that block are actually used by the file.</p>
<h2 id="capacity">Capacity</h2>
<p>Since we are using only a single byte to refer to the next block and each block has a size of 256 bytes, we can have a maximum capacity of
256 x 256 = 65536 bytes with this configuration. The limit is set to this number because if we were to save only one very large file, this would be the file size limit for that file.</p>
<p>We need also keep in mind that not all this space is usable as some space is used by the headers and some space will be used by the descriptor table (explained below).</p>
<p>One more point to note is that an average of 128 bytes will be wasted per file regardless of the file size as only the last block will not be completely filled.</p>
<h2 id="example-of-a-saved-file">Example of a saved file</h2>
<p>Lets say we need to save a file of size 900 bytes. Each block has a usable capacity of 254 bytes in our default configuration so we would need a total of 4 blocks. The first 3 will be fully filled and the last will will have 128 bytes of data saved.</p>
<p>(/shared/figure_01.png)[figure1]</p>

    </body>
    </html>